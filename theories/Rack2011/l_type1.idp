vocabulary V { 
    type Section_T 
    Section: (Section_T) â†’ ğ”¹
    type Element_T 
    Element: (Element_T) â†’ ğ”¹
    type Module_T 
    Module: (Module_T) â†’ ğ”¹
    type slot_T 
    slot: (slot_T) â†’ ğ”¹
    type Rack_T 
    Rack: (Rack_T) â†’ ğ”¹
    SofE: (Element) â†’ Section
    EofM: (Module) â†’ Element
    s_has_Module: (slot) â†’ ğ”¹
    Mofs: (slot) â†’ Module
    Rofs: (slot) â†’ Rack
    SofR: (Rack) â†’ Section
    var S âˆˆ Section
    var E âˆˆ Element
    var M âˆˆ Module
    var s âˆˆ slot
    var R âˆˆ Rack
    mulSection_T: (Section_T) â†’ â„¤
    mulElement_T: (Element_T) â†’ â„¤
    mulModule_T: (Module_T) â†’ â„¤
    mulslot_T: (slot_T) â†’ â„¤
    mulRack_T: (Rack_T) â†’ â„¤
}
theory T:V { 
    [1 â‰¤ #{S : true}]
      1 â‰¤ sum(lambda S âˆˆ Section : mulSection_T(S)).
    [3 â‰¤ #{E : true}]
      3 â‰¤ sum(lambda E âˆˆ Element : mulElement_T(E)).
    [âˆ€ S: 1 â‰¤ #{E : SofE(E) = S} â‰¤ 20]
      âˆ€ S âˆˆ Section: 1 â¨¯ mulSection_T(S) â‰¤ sum(lambda E âˆˆ Element : if SofE(E) = S then mulElement_T(E) else 0) â‰¤ 20 â¨¯ mulSection_T(S).
    [âˆ€ E: 1 â‰¤ #{M : EofM(M) = E} â‰¤ 8]
      âˆ€ E âˆˆ Element: 1 â¨¯ mulElement_T(E) â‰¤ sum(lambda M âˆˆ Module : if EofM(M) = E then mulModule_T(M) else 0) â‰¤ 8 â¨¯ mulElement_T(E).
    [âˆ€ M: #{s : Mofs(s) = M} = 2]
      âˆ€ M âˆˆ Module: sum(lambda s âˆˆ slot : if Mofs(s) = M then mulslot_T(s) else 0) = 2 â¨¯ mulModule_T(M).
    [âˆ€ R: #{s : Rofs(s) = R} = 5]
      âˆ€ R âˆˆ Rack: sum(lambda s âˆˆ slot : if Rofs(s) = R then mulslot_T(s) else 0) = 5 â¨¯ mulRack_T(R).
    [âˆ€ S: 1 â‰¤ #{R : SofR(R) = S} â‰¤ 2]
      âˆ€ S âˆˆ Section: 1 â¨¯ mulSection_T(S) â‰¤ sum(lambda R âˆˆ Rack : if SofR(R) = S then mulRack_T(R) else 0) â‰¤ 2 â¨¯ mulSection_T(S).
    âˆ€ mulSection_T0_ âˆˆ Section_T: 0 â‰¤ mulSection_T(mulSection_T0_).
    âˆ€ mulElement_T0_ âˆˆ Element_T: 0 â‰¤ mulElement_T(mulElement_T0_).
    âˆ€ mulModule_T0_ âˆˆ Module_T: 0 â‰¤ mulModule_T(mulModule_T0_).
    âˆ€ mulslot_T0_ âˆˆ slot_T: 0 â‰¤ mulslot_T(mulslot_T0_).
    âˆ€ mulRack_T0_ âˆˆ Rack_T: 0 â‰¤ mulRack_T(mulRack_T0_).
    âˆ€ E âˆˆ Element: âˆƒ n__5sldkqsdf âˆˆ â„¤: mulElement_T(E) = n__5sldkqsdf â¨¯ mulSection_T(SofE(E)).
    âˆ€ M âˆˆ Module: âˆƒ n__5sldkqsdf âˆˆ â„¤: mulModule_T(M) = n__5sldkqsdf â¨¯ mulElement_T(EofM(M)).
    âˆ€ s âˆˆ slot: âˆƒ n__5sldkqsdf âˆˆ â„¤: mulslot_T(s) = n__5sldkqsdf â¨¯ mulModule_T(Mofs(s)).
    âˆ€ s âˆˆ slot: âˆƒ n__5sldkqsdf âˆˆ â„¤: mulslot_T(s) = n__5sldkqsdf â¨¯ mulRack_T(Rofs(s)).
    âˆ€ R âˆˆ Rack: âˆƒ n__5sldkqsdf âˆˆ â„¤: mulRack_T(R) = n__5sldkqsdf â¨¯ mulSection_T(SofR(R)).
    
    ! x in Section_T: Section(x) <=> 0 < mulSection_T(x).
    ! x in Element_T: Element(x) <=> 0 < mulElement_T(x).
    ! x in Module_T: Module(x) <=> 0 < mulModule_T(x).
    ! x in slot_T: slot(x) <=> 0 < mulslot_T(x).
    ! x in Rack_T: Rack(x) <=> 0 < mulRack_T(x).
    
}

procedure main() {
    logging.getLogger().setLevel(logging.INFO)
    interp, sol = Theory(T).generate(timeout_seconds=0, unsat_seconds=5)
    pretty_print(sol)
    print(duration("Expansion"))
    print("-------------------")
    print(Theory(T).expand_lifting(sol))
    print("-------------------")
}
        